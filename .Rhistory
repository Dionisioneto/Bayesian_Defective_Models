int<lower=0> N;                        // tamanho amostral
vector[N] time;                        // tempo de falha observado
array[N] int<lower=0, upper=1> delta;        // indicador do evento
}
parameters {
real alpha;
real<lower=0> beta;
real<lower=0> lambda;
}
model {
// Prior não informativa para lambda
alpha~normal(0,100);
beta~cauchy(5,5);
lambda~cauchy(0,5);
// Definição manual da função de verossimilhança
for (i in 1:N) {
real z1 = (-1 + alpha * time[i]) / sqrt(beta * time[i]);
real z2 = (-1 - alpha * time[i]) / sqrt(beta * time[i]);
real z3 = (1 + alpha * time[i]) / sqrt(beta * time[i]);
real phi1 = Phi(z1);
real phi2 = Phi(z2);
real phi3 = Phi(z3);
real exp_term = exp(2 * alpha / beta);
// Verossimilhança do evento observado e censurado
target += delta[i]*log((lambda*exp(-(alpha*time[i]-1)^2/2*beta*time[i]))/(sqrt(beta*time[i]^3)*((lambda-1)*phi1 + (lambda-1)*exp_term*phi2 - lambda)^2)) +
(1-delta[i])*log((lambda*(phi1 + exp_term*phi2 - 1))/(-(lambda-1)*phi1+(lambda-1)*exp_term*(phi3+1)-1));
}
}
"
## Transcrever o código escrito para um file stan
writeLines(cod_moig_stan, con = "cod_moig_stan.stan")
data_moig = list(N = dim(dados.moig)[1],
time = dados.moig[,1],
delta = dados.moig[,2])
## Compilar e rodar o modelo
moigfit = stan(file = 'cod_moig_stan.stan', data = data_moig,
chains = 1, iter = 5000, warmup = 300)
a0moig;b0moig;l0moig
summary(moigfit)$summary
moigfit_post_samples = extract(moigfit)
plot(moigfit_post_samples$alpha, type='l')
abline(h=a0moig,col="red", lwd=2)
a0moig
plot(moigfit_post_samples$beta, type='l')
abline(h=b0moig,col="red", lwd=2)
plot(moigfit_post_samples$lambda, type='l')
abline(h=l0moig,col="red", lwd=2)
cod_moig_stan = "
data {
int<lower=0> N;                        // tamanho amostral
vector[N] time;                        // tempo de falha observado
array[N] int<lower=0, upper=1> delta;        // indicador do evento
}
parameters {
real alpha;
real<lower=0> beta;
real<lower=0> lambda;
}
model {
// Prior não informativa para lambda
alpha~normal(0,10);
beta~gamma(0.001,0.001);
lambda~cauchy(0,5);
// Definição manual da função de verossimilhança
for (i in 1:N) {
real z1 = (-1 + alpha * time[i]) / sqrt(beta * time[i]);
real z2 = (-1 - alpha * time[i]) / sqrt(beta * time[i]);
real z3 = (1 + alpha * time[i]) / sqrt(beta * time[i]);
real phi1 = Phi(z1);
real phi2 = Phi(z2);
real phi3 = Phi(z3);
real exp_term = exp(2 * alpha / beta);
// Verossimilhança do evento observado e censurado
target += delta[i]*log((lambda*exp(-(alpha*time[i]-1)^2/2*beta*time[i]))/(sqrt(beta*time[i]^3)*((lambda-1)*phi1 + (lambda-1)*exp_term*phi2 - lambda)^2)) +
(1-delta[i])*log((lambda*(phi1 + exp_term*phi2 - 1))/(-(lambda-1)*phi1+(lambda-1)*exp_term*(phi3+1)-1));
}
}
"
## Transcrever o código escrito para um file stan
writeLines(cod_moig_stan, con = "cod_moig_stan.stan")
data_moig = list(N = dim(dados.moig)[1],
time = dados.moig[,1],
delta = dados.moig[,2])
## Compilar e rodar o modelo
moigfit = stan(file = 'cod_moig_stan.stan', data = data_moig,
chains = 1, iter = 5000, warmup = 300)
a0moig;b0moig;l0moig
summary(moigfit)$summary
moigfit_post_samples = extract(moigfit)
plot(moigfit_post_samples$alpha, type='l')
abline(h=a0moig,col="red", lwd=2)
plot(moigfit_post_samples$beta, type='l')
abline(h=b0moig,col="red", lwd=2)
plot(moigfit_post_samples$lambda, type='l')
plot(moigfit_post_samples$beta, type='l')
abline(h=b0moig,col="red", lwd=2)
b0moig
plot(moigfit_post_samples$lambda, type='l')
abline(h=l0moig,col="red", lwd=2)
a0moig;b0moig;l0moig
summary(moigfit)$summary
cod_moig_stan = "
data {
int<lower=0> N;                        // tamanho amostral
vector[N] time;                        // tempo de falha observado
array[N] int<lower=0, upper=1> delta;        // indicador do evento
real lambda;
}
parameters {
real alpha;
real<lower=0> beta;
//real<lower=0> lambda;
}
model {
// Prior não informativa para lambda
alpha~normal(0,10);
beta~gamma(0.001,0.001);
//lambda~cauchy(0,5);
// Definição manual da função de verossimilhança
for (i in 1:N) {
real z1 = (-1 + alpha * time[i]) / sqrt(beta * time[i]);
real z2 = (-1 - alpha * time[i]) / sqrt(beta * time[i]);
real z3 = (1 + alpha * time[i]) / sqrt(beta * time[i]);
real phi1 = Phi(z1);
real phi2 = Phi(z2);
real phi3 = Phi(z3);
real exp_term = exp(2 * alpha / beta);
// Verossimilhança do evento observado e censurado
target += delta[i]*log((lambda*exp(-(alpha*time[i]-1)^2/2*beta*time[i]))/(sqrt(beta*time[i]^3)*((lambda-1)*phi1 + (lambda-1)*exp_term*phi2 - lambda)^2)) +
(1-delta[i])*log((lambda*(phi1 + exp_term*phi2 - 1))/(-(lambda-1)*phi1+(lambda-1)*exp_term*(phi3+1)-1));
}
}
"
## Transcrever o código escrito para um file stan
writeLines(cod_moig_stan, con = "cod_moig_stan.stan")
data_moig = list(N = dim(dados.moig)[1],
time = dados.moig[,1],
delta = dados.moig[,2])
data_moig = list(N = dim(dados.moig)[1],
time = dados.moig[,1],
delta = dados.moig[,2],
lambda = l0moig)
## Compilar e rodar o modelo
moigfit = stan(file = 'cod_moig_stan.stan', data = data_moig,
chains = 1, iter = 5000, warmup = 300)
a0moig;b0moig;l0moig
summary(moigfit)$summary
moigfit_post_samples = extract(moigfit)
plot(moigfit_post_samples$alpha, type='l')
abline(h=a0moig,col="red", lwd=2)
plot(moigfit_post_samples$beta, type='l')
abline(h=b0moig,col="red", lwd=2)
plot(moigfit_post_samples$lambda, type='l')
abline(h=l0moig,col="red", lwd=2)
cod_moig_stan = "
data {
int<lower=0> N;                        // tamanho amostral
vector[N] time;                        // tempo de falha observado
array[N] int<lower=0, upper=1> delta;        // indicador do evento
real beta;
}
parameters {
real alpha;
//real<lower=0> beta;
real<lower=0> lambda;
}
model {
// Prior não informativa para lambda
alpha~normal(0,10);
//beta~gamma(0.001,0.001);
lambda~cauchy(0,5);
// Definição manual da função de verossimilhança
for (i in 1:N) {
real z1 = (-1 + alpha * time[i]) / sqrt(beta * time[i]);
real z2 = (-1 - alpha * time[i]) / sqrt(beta * time[i]);
real z3 = (1 + alpha * time[i]) / sqrt(beta * time[i]);
real phi1 = Phi(z1);
real phi2 = Phi(z2);
real phi3 = Phi(z3);
real exp_term = exp(2 * alpha / beta);
// Verossimilhança do evento observado e censurado
target += delta[i]*log((lambda*exp(-(alpha*time[i]-1)^2/2*beta*time[i]))/(sqrt(beta*time[i]^3)*((lambda-1)*phi1 + (lambda-1)*exp_term*phi2 - lambda)^2)) +
(1-delta[i])*log((lambda*(phi1 + exp_term*phi2 - 1))/(-(lambda-1)*phi1+(lambda-1)*exp_term*(phi3+1)-1));
}
}
"
## Transcrever o código escrito para um file stan
writeLines(cod_moig_stan, con = "cod_moig_stan.stan")
data_moig = list(N = dim(dados.moig)[1],
time = dados.moig[,1],
delta = dados.moig[,2],
beta = b0moig)
## Compilar e rodar o modelo
moigfit = stan(file = 'cod_moig_stan.stan', data = data_moig,
chains = 1, iter = 5000, warmup = 300)
a0moig;b0moig;l0moig
moigfit_post_samples = extract(moigfit)
plot(moigfit_post_samples$alpha, type='l')
abline(h=a0moig,col="red", lwd=2)
plot(moigfit_post_samples$beta, type='l')
abline(h=b0moig,col="red", lwd=2)
plot(moigfit_post_samples$lambda, type='l')
abline(h=l0moig,col="red", lwd=2)
l0moig
cod_moig_stan = "
data {
int<lower=0> N;                        // tamanho amostral
vector[N] time;                        // tempo de falha observado
array[N] int<lower=0, upper=1> delta;        // indicador do evento
real beta;
real lambda;
}
parameters {
real alpha;
//real<lower=0> beta;
//real<lower=0> lambda;
}
model {
// Prior não informativa para lambda
alpha~normal(0,10);
//beta~gamma(0.001,0.001);
//lambda~cauchy(0,5);
// Definição manual da função de verossimilhança
for (i in 1:N) {
real z1 = (-1 + alpha * time[i]) / sqrt(beta * time[i]);
real z2 = (-1 - alpha * time[i]) / sqrt(beta * time[i]);
real z3 = (1 + alpha * time[i]) / sqrt(beta * time[i]);
real phi1 = Phi(z1);
real phi2 = Phi(z2);
real phi3 = Phi(z3);
real exp_term = exp(2 * alpha / beta);
// Verossimilhança do evento observado e censurado
target += delta[i]*log((lambda*exp(-(alpha*time[i]-1)^2/2*beta*time[i]))/(sqrt(beta*time[i]^3)*((lambda-1)*phi1 + (lambda-1)*exp_term*phi2 - lambda)^2)) +
(1-delta[i])*log((lambda*(phi1 + exp_term*phi2 - 1))/(-(lambda-1)*phi1+(lambda-1)*exp_term*(phi3+1)-1));
}
}
"
## Transcrever o código escrito para um file stan
writeLines(cod_moig_stan, con = "cod_moig_stan.stan")
data_moig = list(N = dim(dados.moig)[1],
time = dados.moig[,1],
delta = dados.moig[,2],
beta = b0moig,
lambda = l0moig)
## Compilar e rodar o modelo
moigfit = stan(file = 'cod_moig_stan.stan', data = data_moig,
chains = 1, iter = 5000, warmup = 300)
## Compilar e rodar o modelo
moigfit = stan(file = 'cod_moig_stan.stan', data = data_moig,
chains = 1, iter = 5000, warmup = 300)
a0moig;b0moig;l0moig
summary(moigfit)$summary
cod_moig_stan = "
data {
int<lower=0> N;                        // tamanho amostral
vector[N] time;                        // tempo de falha observado
array[N] int<lower=0, upper=1> delta;        // indicador do evento
real beta;
real lambda;
}
parameters {
real alpha;
//real<lower=0> beta;
//real<lower=0> lambda;
}
model {
// Prior não informativa para lambda
alpha~normal(0,10);
//beta~gamma(0.001,0.001);
//lambda~cauchy(0,5);
// Definição manual da função de verossimilhança
for (i in 1:N) {
real z1 = (-1 + alpha * time[i]) / sqrt(beta * time[i]);
real z2 = (-1 - alpha * time[i]) / sqrt(beta * time[i]);
real z3 = (1 + alpha * time[i]) / sqrt(beta * time[i]);
real phi1 = Phi(z1);
real phi2 = Phi(z2);
real phi3 = Phi(z3);
real exp_term = exp(2 * alpha / beta);
// Verossimilhança do evento observado e censurado
target += delta[i]*log((lambda*exp(-(alpha*time[i]-1)^2/2*beta*time[i]))/(sqrt(beta*time[i]^3)*((lambda-1)*phi1 + (lambda-1)*exp_term*phi2 - lambda)^2)) +
(1-delta[i])*log((lambda*(phi1 + exp_term*phi2 - 1))/(-(lambda-1)*phi1+(lambda-1)*exp_term*(phi3+1)-1));
}
}
"
## Transcrever o código escrito para um file stan
writeLines(cod_moig_stan, con = "cod_moig_stan.stan")
data_moig = list(N = dim(dados.moig)[1],
time = dados.moig[,1],
delta = dados.moig[,2],
beta = b0moig,
lambda = l0moig)
## Compilar e rodar o modelo
moigfit = stan(file = 'cod_moig_stan.stan', data = data_moig,
chains = 1, iter = 5000, warmup = 300)
# -------------------------------------------------------------------------------
library(pacman)
p_load(survival,rstan, R2jags,rjags)
# ---
### ------
### 5. Geração de dados do modelo Kumaraswamy Gompertz defeituoso ====
### para fração de cura da tese do Ricardo Ferreira
### ------
# 5.1: Funções Importantes.
# Obs.: We need to run the functions ft_Gompertz and St_Gompertz.
ft_Gompertz = function(t,alpha,beta){
ft = beta*exp(alpha*beta)*exp(-(beta/alpha)*(exp(alpha*t)-1))
return(ft)
}
Ft_Gompertz = function(t,alpha,beta){
Ft = 1 - exp(-(beta/alpha)*(exp(alpha*t)-1))
return(Ft)
}
St_Gompertz = function(t,alpha,beta){
st = exp(-(beta/alpha)*(exp(alpha*t)-1))
return(st)
}
# t: Failure time.
# alpha, beta: Shape parameters.
ft_Kgompertz = function(t,alpha,beta,kappa,psi){
den1 = kappa*psi*ft_Gompertz(t=t,alpha=alpha,beta=beta)
den2 = Ft_Gompertz(t=t,alpha=alpha,beta=beta)^(psi-1)*(1-Ft_Gompertz(t=t,alpha=alpha,beta=beta)^(psi))^(kappa-1)
return(den1*den2)
}
Ft_Kgompertz = function(t,alpha,beta,kappa,psi){
surv = (1 - Ft_Gompertz(t=t,alpha=alpha,beta=beta)^(psi))^(kappa)
return(1-surv)
}
st_Kgompertz = function(t,alpha,beta,kappa,psi){
surv = (1 - Ft_Gompertz(t=t,alpha=alpha,beta=beta)^(psi))^(kappa)
return(surv)
}
# 5.2: Algoritmo de geração de dados sob a F(t).
# Temos a forma fechada para a t = F^-1(u)!
gen.cure.kgz = function(n,a,b,k,ps,p){
finv.kgz = function(t,alpha,beta,kappa,psi,unif){Ft_Kgompertz(t=t,alpha=alpha,beta=beta,kappa=kappa,psi=psi)-unif}
ger.kgz = function(alpha,beta,kappa,psi,unif){t=uniroot(finv.kgz,c(0,1000),tol=0.01,alpha=alpha,beta=beta,kappa=kappa,psi=psi,unif=unif);return(t$root)}
rm = rbinom(n=n,size=1,prob=1-p)
un = runif(n=n,0,max=1-p)
t = rep(NA,n)
for(i in 1:n){
t[i]=ifelse(rm[i]==0, Inf, ger.kgz(alpha=a,beta=b,kappa=k,psi=ps,unif=un[i]))
}
t_finite = ifelse(t==Inf,0,t)
u2 = runif(n=n,0,max(t_finite))
t2 = pmin(t,u2); delta = ifelse(t<u2,1,0)
return(cbind(t2,delta))
}
n=800
a0kg=-1
b0kg=2
psi0kg=0.95
k0kg=1.05
pgkg = exp(b0kg/a0kg)
p0kg = (1-(1-pgkg)^psi0kg)^k0kg; p0kg
dados.kgz=gen.cure.kgz(n=n,a=a0kg,b=b0kg,k=k0kg,ps=psi0kg,p=p0kg)
head(dados.kgz)
cod_kgtz_stan = "
data{
int<lower=0> N;
array[N] real time;
array[N] int<lower=0, upper=1> delta;
}
parameters{
real alpha;
real<lower=0> beta;
real<lower=0> psi;
real<lower=0> kappa;
}
model{
// prioris
alpha ~ normal(-1,100);
beta ~ gamma(0.001,0.001);
kappa ~ cauchy(0,5);
psi ~  cauchy(0,5);
// Definição manual da função de verossimilhança
for(i in 1:N){
target += delta[i]*(log(kappa*psi*beta*exp(alpha*time[i])*(exp((beta-beta*exp(alpha*time[i]))/alpha))^(psi) * (1-(1-(exp((beta-beta*exp(alpha*time[i]))/alpha))^psi))^(kappa-1))) +
(1 - delta[i])*(log((1 - (1 - exp((beta-beta*exp(alpha*time[i]))/alpha))^psi)^kappa));
}
}
"
## Transcrever o código escrito para um file stan
writeLines(cod_kgtz_stan, con = "cod_kgtz_stan.stan")
data_kgz = list(N = dim(dados.kgz)[1],
time = dados.kgz[,1],
delta = dados.kgz[,2])
## Compilar e rodar o modelo
kgzfit = stan(file = 'cod_kgtz_stan.stan', data = data_kgz,
chains = 1, iter = 5000, warmup = 300)
a0kg;b0kg;psi0kg;k0kg
summary(kgzfit)$summary
kgzfit_post_samples = extract(kgzfit)
plot(kgzfit_post_samples$alpha, type='l')
abline(h=a0kg,col="red", lwd=2)
plot(kgzfit_post_samples$beta, type='l')
abline(h=b0kg,col="red", lwd=2)
plot(kgzfit_post_samples$psi, type='l')
abline(h=psi0kg,col="red", lwd=2)
plot(kgzfit_post_samples$kappa, type='l')
abline(h=psi0kg,col="red", lwd=2)
cod_kgtz_stan = "
data{
int<lower=0> N;
array[N] real time;
array[N] int<lower=0, upper=1> delta;
}
parameters{
real alpha;
real<lower=0> beta;
real<lower=0> psi;
real<lower=0> kappa;
}
model{
// prioris
alpha ~ normal(-1,100);
beta ~  cauchy(0,5);
kappa ~ cauchy(0,5);
psi ~  cauchy(0,5);
// Definição manual da função de verossimilhança
for(i in 1:N){
target += delta[i]*(log(kappa*psi*beta*exp(alpha*time[i])*(exp((beta-beta*exp(alpha*time[i]))/alpha))^(psi) * (1-(1-(exp((beta-beta*exp(alpha*time[i]))/alpha))^psi))^(kappa-1))) +
(1 - delta[i])*(log((1 - (1 - exp((beta-beta*exp(alpha*time[i]))/alpha))^psi)^kappa));
}
}
"
## Transcrever o código escrito para um file stan
writeLines(cod_kgtz_stan, con = "cod_kgtz_stan.stan")
data_kgz = list(N = dim(dados.kgz)[1],
time = dados.kgz[,1],
delta = dados.kgz[,2])
## Compilar e rodar o modelo
kgzfit = stan(file = 'cod_kgtz_stan.stan', data = data_kgz,
chains = 1, iter = 4000, warmup = 300)
a0kg;b0kg;psi0kg;k0kg
summary(kgzfit)$summary
kgzfit_post_samples = extract(kgzfit)
plot(kgzfit_post_samples$alpha, type='l')
abline(h=a0kg,col="red", lwd=2)
plot(kgzfit_post_samples$beta, type='l')
abline(h=b0kg,col="red", lwd=2)
plot(kgzfit_post_samples$psi, type='l')
abline(h=psi0kg,col="red", lwd=2)
plot(kgzfit_post_samples$kappa, type='l')
abline(h=psi0kg,col="red", lwd=2)
a0kg;b0kg;psi0kg;k0kg
summary(kgzfit)$summary
n=2000
a0kg=-1
b0kg=2
psi0kg=0.95
k0kg=1.05
pgkg = exp(b0kg/a0kg)
p0kg = (1-(1-pgkg)^psi0kg)^k0kg; p0kg
dados.kgz=gen.cure.kgz(n=n,a=a0kg,b=b0kg,k=k0kg,ps=psi0kg,p=p0kg)
head(dados.kgz)
#prop.table(table(dados.kgz[,2]))
# ---
# 5.3 Programação no stan  ====
# ---
## Portanto, no objeto dados.mog,
## temos os dados do tempo de falha e o indicador de censura.
## Vamos atribuir uma priori para alpha, beta e lambda não informativas.
## Revisar o código, pois o amaostrador não está rodando nos valores iniciais
cod_kgtz_stan = "
data{
int<lower=0> N;
array[N] real time;
array[N] int<lower=0, upper=1> delta;
}
parameters{
real alpha;
real<lower=0> beta;
real<lower=0> psi;
real<lower=0> kappa;
}
model{
// prioris
alpha ~ normal(-1,10);
beta ~  cauchy(0,5);
kappa ~ cauchy(0,5);
psi ~  cauchy(0,5);
// Definição manual da função de verossimilhança
for(i in 1:N){
target += delta[i]*(log(kappa*psi*beta*exp(alpha*time[i])*(exp((beta-beta*exp(alpha*time[i]))/alpha))^(psi) * (1-(1-(exp((beta-beta*exp(alpha*time[i]))/alpha))^psi))^(kappa-1))) +
(1 - delta[i])*(log((1 - (1 - exp((beta-beta*exp(alpha*time[i]))/alpha))^psi)^kappa));
}
}
"
## Transcrever o código escrito para um file stan
writeLines(cod_kgtz_stan, con = "cod_kgtz_stan.stan")
## Organizando os dados [data list]
#dados.kgz
data_kgz = list(N = dim(dados.kgz)[1],
time = dados.kgz[,1],
delta = dados.kgz[,2])
## Compilar e rodar o modelo
kgzfit = stan(file = 'cod_kgtz_stan.stan', data = data_kgz,
chains = 1, iter = 4000, warmup = 300)
a0kg;b0kg;psi0kg;k0kg
summary(kgzfit)$summary
a0kg;b0kg;psi0kg;k0kg
summary(kgzfit)$summary
kgzfit_post_samples = extract(kgzfit)
plot(kgzfit_post_samples$alpha, type='l')
abline(h=a0kg,col="red", lwd=2)
plot(kgzfit_post_samples$beta, type='l')
abline(h=b0kg,col="red", lwd=2)
plot(kgzfit_post_samples$psi, type='l')
abline(h=psi0kg,col="red", lwd=2)
plot(kgzfit_post_samples$kappa, type='l')
abline(h=psi0kg,col="red", lwd=2)
